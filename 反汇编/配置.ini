<name =%图像增强>2<%End><name =%图片>true<%End><name =%tux>true<%End><name =%子文件>false<%End><name =%tcpds>23<%End><name =%tcpips>192.168.1.102<%End><name =%tcpdc>23<%End><name =%tcpipc>192.168.1.102<%End><name =%缓存路径><%End><name =%串口><%End><name =%波特率>115200<%End><name =%仿真字体大小>9<%End><name =%仿真代码备份><$n|nr><$n|nr><$n|nr>void GetHistGram(uint8 Image[MT9V03X_H][MT9V03X_W])<$n|nr>{<$n|nr>    int X,Y;<$n|nr>    for (Y = 0; Y < 256; Y++)<$n|nr>    {<$n|nr>        HistGram[Y] = 0; //初始化灰度直方图<$n|nr>    }<$n|nr>    for (Y = 0; Y < MT9V03X_H; Y++)<$n|nr>    {<$n|nr>        for (X = 0; X < MT9V03X_W; X++)<$n|nr>        {<$n|nr>            HistGram[Image[Y][X]]++; //统计每个灰度值的个数信息<$n|nr>        }<$n|nr>    }<$n|nr>}<$n|nr><$n|nr><$n|nr>//大津法计算阈值 最大类间方差<$n|nr>int OTSU_threshold(uint8 *image, uint16 col, uint16 row)   //注意计算阈值的一定要是原图像<$n|nr>{<$n|nr>    uint8 threshold = 0;<$n|nr>    int pixelCount[GrayScale];<$n|nr>    float pixelPro[GrayScale];<$n|nr>    int i = 0, j = 0, pixelSum = col * row/4;<$n|nr>    uint32 gray_sum=0;<$n|nr>    float w0 = 0.000000000f,<$n|nr>        w1 = 0.000000000f,<$n|nr>        u0tmp = 0.000000000f,<$n|nr>        u1tmp = 0.000000000f,<$n|nr>        u0 = 0.000000000f,<$n|nr>        u1 = 0.000000000f,<$n|nr>        u = 0.000000000f,<$n|nr>        deltaTmp = 0.000000000f,<$n|nr>        deltaMax = 0.000000000f;<$n|nr>    uint16 StartSearchThreshold;<$n|nr>    for (i = 0; i < GrayScale; i++)<$n|nr>    {<$n|nr>        pixelCount[i] = 0;<$n|nr>        pixelPro[i] = 0;<$n|nr>    }<$n|nr>    //统计灰度级中每个像素在整幅图像中的个数<$n|nr>    for (i = 0; i < row; i+=2)<$n|nr>    {<$n|nr>        for (j = 0; j < col; j+=2)<$n|nr>        {<$n|nr>            pixelCount[(int)(image[i * col + j])]++;  //将当前的点的像素值作为计数数组的下标<$n|nr>            gray_sum+=(int)(image[i * col + j]);       //灰度值总和<$n|nr>        }<$n|nr>    }<$n|nr>    //计算每个像素值的点在整幅图像中的比例<$n|nr>    for (i = 0; i < GrayScale; i++)<$n|nr>    {<$n|nr>        pixelPro[i] = (float)pixelCount[i] / pixelSum;<$n|nr>    }<$n|nr>    //计算开始进行扫描的灰度值<$n|nr>    for(j = 0;j < GrayScale;j ++)<$n|nr>    {<$n|nr>        if(pixelPro[j] != 0.0f)<$n|nr>        {<$n|nr>            StartSearchThreshold = j + 2;<$n|nr>            break;<$n|nr>        }<$n|nr>    }<$n|nr>    //跳过一些灰度值 这些值不可作为阈值<$n|nr>    for(j = 0;j < StartSearchThreshold;j ++)<$n|nr>    {<$n|nr>        w0 += pixelPro[j];<$n|nr>        u0tmp += (float)(j * pixelPro[j]);<$n|nr>    }<$n|nr>    //遍历灰度级[0,255]  从需要值开始遍历<$n|nr>    for (j = StartSearchThreshold; j < GrayScale; j++)<$n|nr>    {<$n|nr>        w0 += pixelPro[j];  //背景部分每个灰度值的像素点所占比例之和   即背景部分的比例<$n|nr>        u0tmp += (float)(j * pixelPro[j]);  //背景部分 每个灰度值的点的比例 *灰度值<$n|nr><$n|nr>        w1= (float)(1 - w0);<$n|nr>        u1tmp=(float)(gray_sum/pixelSum-u0tmp);<$n|nr><$n|nr>        u0 = u0tmp / w0;              //背景平均灰度<$n|nr>        u1 = u1tmp / w1;              //前景平均灰度<$n|nr>        u = u0tmp + u1tmp;            //全局平均灰度<$n|nr>        deltaTmp = w0 * (u0 - u) * (u0 - u) + w1 * (u1 - u) * (u1 - u0);<$n|nr>        if (deltaTmp >= deltaMax)<$n|nr>        {<$n|nr>            deltaMax = deltaTmp;<$n|nr>            threshold = j;<$n|nr>        }<$n|nr>        if (deltaTmp < deltaMax)<$n|nr>        {<$n|nr>            break;<$n|nr>        }<$n|nr>     }<$n|nr><$n|nr>    return threshold;<$n|nr>}<$n|nr>//-------------------------------------------------------------------------------------------------------------------<$n|nr>//  @brief      大津法确定黑白阈值函数<$n|nr>//  @return     uint8_t<$n|nr>//-------------------------------------------------------------------------------------------------------------------<$n|nr>int otsuBWThresholdSet()<$n|nr>{<$n|nr>//  float n=0,m=0,n0=0,m0=0,n1=0,m1=0;//总像素数，总平均像素值，背景像素数，背景平均像素值，前景像素数，前景平均像素值<$n|nr>//  float T=0,gNOW=0,gLAST=0;//阈值，当前方差，上次方差<$n|nr>//<$n|nr>//  int i,j,k;//遍历所用变量<$n|nr>//<$n|nr>//  n=MT9V03X_H*MT9V03X_W;<$n|nr>//  for(i=0;i<MT9V03X_H;i++)<$n|nr>//      for(j=0;j<MT9V03X_H;j++)<$n|nr>//          m0+=mt9v03x_image[i][j];<$n|nr>//  m/=n;<$n|nr>//  for(k=120;k<230;k++)<$n|nr>//  {<$n|nr>//      //背景像素数、背景平均像素值处理<$n|nr>//      for(i=0;i<MT9V03X_H;i++)<$n|nr>//          for(j=0;j<MT9V03X_H;j++)<$n|nr>//              if(mt9v03x_image[i][j]<=k)<$n|nr>//              {<$n|nr>//                  m0++;<$n|nr>//                  n0+=mt9v03x_image[i][j];<$n|nr>//              }<$n|nr>//      n0/=m0;<$n|nr>//      //前景像素数、前景平均像素值处理<$n|nr>//      for(i=0;i<MT9V03X_H;i++)<$n|nr>//          for(j=0;j<MT9V03X_H;j++)<$n|nr>//              if(mt9v03x_image[i][j]>k)<$n|nr>//              {<$n|nr>//                  m1++;<$n|nr>//                  n1+=mt9v03x_image[i][j];<$n|nr>//              }<$n|nr>//      n1/=m1;<$n|nr>//      gNOW=(n0/n)*(n1/n)*(m0-m1)*(m0-m1);<$n|nr>//      if(gNOW>gLAST)T=k;<$n|nr>//  }<$n|nr>//<$n|nr>//  BWThreshold=T;<$n|nr>    int16 Y;<$n|nr>    uint32 Amount = 0;<$n|nr>    uint32 PixelBack = 0;<$n|nr>    uint32 PixelIntegralBack = 0;<$n|nr>    uint32 PixelIntegral = 0;<$n|nr>    int32 PixelIntegralFore = 0;<$n|nr>    int32 PixelFore = 0;<$n|nr>    float OmegaBack, OmegaFore, MicroBack, MicroFore, SigmaB, Sigma; // 类间方差;<$n|nr>    int16 MinValue, MaxValue;<$n|nr>    uint8 Threshold = 0;<$n|nr><$n|nr>    for (MinValue = 0; MinValue < 256 && HistGram[MinValue] == 0; MinValue++) ;        //获取最小灰度的值<$n|nr>    for (MaxValue = 255; MaxValue > MinValue && HistGram[MinValue] == 0; MaxValue--) ; //获取最大灰度的值<$n|nr><$n|nr>    if (MaxValue == MinValue)<$n|nr>    {<$n|nr>        return MaxValue;          // 图像中只有一个颜色<$n|nr>    }<$n|nr>    if (MinValue + 1 == MaxValue)<$n|nr>    {<$n|nr>        return MinValue;      // 图像中只有二个颜色<$n|nr>    }<$n|nr><$n|nr>    for (Y = MinValue; Y <= MaxValue; Y++)<$n|nr>    {<$n|nr>        Amount += HistGram[Y];        //  像素总数<$n|nr>    }<$n|nr><$n|nr>    PixelIntegral = 0;<$n|nr>    for (Y = MinValue; Y <= MaxValue; Y++)<$n|nr>    {<$n|nr>         PixelIntegral += HistGram[Y] * Y;//灰度值总数<$n|nr>    }<$n|nr>    SigmaB = -1;<$n|nr>    for (Y = MinValue; Y < MaxValue; Y++)<$n|nr>    {<$n|nr>         PixelBack = PixelBack + HistGram[Y];    //前景像素点数<$n|nr>         PixelFore = Amount - PixelBack;         //背景像素点数<$n|nr>         OmegaBack = (float)PixelBack / Amount;//前景像素百分比<$n|nr>         OmegaFore = (float)PixelFore / Amount;//背景像素百分比<$n|nr>         PixelIntegralBack += HistGram[Y] * Y;  //前景灰度值<$n|nr>         PixelIntegralFore = PixelIntegral - PixelIntegralBack;//背景灰度值<$n|nr>         MicroBack = (float)PixelIntegralBack / PixelBack;//前景灰度百分比<$n|nr>         MicroFore = (float)PixelIntegralFore / PixelFore;//背景灰度百分比<$n|nr>         Sigma = OmegaBack * OmegaFore * (MicroBack - MicroFore) * (MicroBack - MicroFore);//g<$n|nr>         if (Sigma > SigmaB)//遍历最大的类间方差g（已改变参数SigmaB，会降低图像稳定性）<$n|nr>         {<$n|nr>              SigmaB = Sigma;<$n|nr>              Threshold = Y;<$n|nr>         }<$n|nr>    }<$n|nr>    return Threshold;<$n|nr><$n|nr>}<$n|nr><$n|nr><$n|nr>//-------------------------------------------------------------------------------------------------------------------<$n|nr>//  @brief      图像二值化函数<$n|nr>//  @return     void<$n|nr>//-------------------------------------------------------------------------------------------------------------------<$n|nr><$n|nr>void main()<$n|nr>{<$n|nr>    int i,j;<$n|nr>    for(i = 0; i < MT9V03X_H; i++)<$n|nr>    {<$n|nr>        for(j = 0; j < MT9V03X_W; j++)<$n|nr>        {<$n|nr>            image_Binarization[i][j] = mt9v03x_image[i][j];<$n|nr>            if(image_Binarization[i][j]<=BWThreshold)//小于阈值为黑<$n|nr>            {<$n|nr>                image_Binarization[i][j]=0;<$n|nr>            }<$n|nr>            if(image_Binarization[i][j]>BWThreshold)//大于阈值为白<$n|nr>            {<$n|nr>                image_Binarization[i][j]=255;<$n|nr>            }<$n|nr>        }<$n|nr>    }<$n|nr>}<$n|nr>void Extract_test()<$n|nr>{<$n|nr>    int H,W;<$n|nr>    for(H=MT9V03X_H;H>0;H--)<$n|nr>    {<$n|nr>        //扫描右边线<$n|nr>        //除了第一次，每次从上一次的中线位置开始扫描<$n|nr>        if(H==MT9V03X_H)W=MT9V03X_W/2;<$n|nr>        else W=Centerline[H+1];<$n|nr><$n|nr>            for(;W<MT9V03X_W;W++)<$n|nr>            {<$n|nr>                if(image_Binarization[W][H]==0 && image_Binarization[W+1][H]==0 && Leftline[H]>0)//注意越界<$n|nr>                {<$n|nr>                    Rightfindflag[H]=1;<$n|nr>                    Rightline[H]=W-1;<$n|nr>                    break;<$n|nr>                }<$n|nr>            }<$n|nr><$n|nr>            //扫描左边线<$n|nr>            //除了第一次，每次从上一次的中线位置开始扫描<$n|nr>            if(H==MT9V03X_H)W=MT9V03X_W/2;<$n|nr>            else W=Centerline[H+1];<$n|nr><$n|nr>            for(;W>0;W--)<$n|nr>            {<$n|nr>                if(image_Binarization[W][H]==0 && image_Binarization[W-1][H]==0 && Leftline[H]<255)//注意越界<$n|nr>                {<$n|nr>                    Leftfindflag[H]=1;<$n|nr>                    Leftline[H]=W+1;<$n|nr>                    break;<$n|nr>                }<$n|nr>            }<$n|nr><$n|nr>            //记录赛道宽度和中线位置<$n|nr>            fiv_width[H]=Rightline[H]-Leftline[H];<$n|nr>            Centerline[H]=(Leftline[H]+Rightline[H])/2;<$n|nr>        }<$n|nr>for(int x=MT9V03X_H;x>0;x--)<$n|nr>{<$n|nr>	lcd_drawpoint(x,Centerline[x],RED); <$n|nr>}<$n|nr>print_int(Centerline[15]);<$n|nr>}<%End><name =%仿真字体>宋体<%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End><%End>